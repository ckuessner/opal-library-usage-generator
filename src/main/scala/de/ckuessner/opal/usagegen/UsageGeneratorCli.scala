package de.ckuessner.opal.usagegen

import de.ckuessner.opal.usagegen.generators.UsageClassGenerator
import org.opalj.br.analyses.Project
import org.opalj.log.{ConsoleOPALLogger, GlobalLogContext, OPALLogger}
import scopt.OParser

import java.io.File
import java.lang.reflect.{InvocationTargetException, Modifier}
import java.util.ResourceBundle
import scala.reflect.internal.util.ScalaClassLoader.URLClassLoader

object UsageGeneratorCli extends App {
  case class Config(projectJarFile: File,
                    outputJarFile: File,
                    force: Boolean = false,
                    runBytecode: Boolean = false,
                    verbose: Boolean = false)

  val builder = OParser.builder[Config]
  val argParser = {
    import builder._
    OParser.sequence(
      arg[File]("libraryJarFile")
        .text("Path to the JAR file containing the tested library")
        .required()
        .validate(file =>
          if (file.exists()) success
          else failure("File " + file.toString + " does not exist")
        )
        .action((file, c) => c.copy(projectJarFile = file)),

      arg[File]("outputJarFile")
        .text("Path to the output JAR file that contains the generated usage code")
        .required()
        .validate(file =>
          if (file.getName.matches(".*\\.(jar|zip)"))
            success
          else
            failure("outputJarFile must end with .jar or .zip")
        ).action((file, c) => c.copy(outputJarFile = file)),

      opt[Unit]('f', "force")
        .text("Overwrite outputJarFile if it already exists")
        .optional()
        .action((_, c) => c.copy(force = true)),

      opt[Unit]('r', "run")
        .text("Run generated bytecode after generation")
        .optional()
        .action((_, c) => c.copy(runBytecode = true)),

      opt[Unit]('v', "verbose")
        .text("Increase logging verbosity")
        .optional()
        .action((_, c) => c.copy(verbose = true)),

      help('h', "help")
        .text("Print this usage text"),

      checkConfig(c =>
        if (!c.force && c.outputJarFile != null && c.outputJarFile.exists())
          failure("File " + c.outputJarFile + " already exists, use -f to override outputJarFile")
        else
          success
      )
    )
  }

  // OParser.parse returns Option[Config]
  OParser.parse(argParser, args, Config(null, null)) match {
    case Some(config) => run(config)
    case _ => // Invalid parameters, errors logged by scopt
  }

  def run(config: Config): Unit = {
    // TODO: remove after refactor
    val CALLER_CLASS_NAME = "ApiCaller"
    val SINK_CLASS_NAME = "ApiSink"

    // Silence Info level logs from opal
    val opalLogLevel =
      if (config.verbose) org.opalj.log.Info
      else org.opalj.log.Warn

    OPALLogger.updateLogger(GlobalLogContext, new ConsoleOPALLogger(true, opalLogLevel))
    val project = Project(config.projectJarFile, new ConsoleOPALLogger(true, opalLogLevel))

    val (callerClass, sinkClass) = UsageClassGenerator.buildCallerWithSink(
      project,
      CALLER_CLASS_NAME,
      SINK_CLASS_NAME
    )

    UsageClassGenerator.writeToJarFile(
      config.outputJarFile,
      List(callerClass, sinkClass),
      config.force
    )

    if (config.runBytecode) {
      ResourceBundle.clearCache(ClassLoader.getSystemClassLoader)
      val cl: ClassLoader = new URLClassLoader(Seq(
        config.projectJarFile.toURI.toURL, // Classloader needs both library jar file
        config.outputJarFile.toURI.toURL // as well as generated jar file
      ), null)
      ResourceBundle.clearCache(cl)

      val testProjectCallerClass = cl.loadClass(CALLER_CLASS_NAME)

      testProjectCallerClass.getMethods.foreach(method => {
        if (Modifier.isStatic(method.getModifiers)) {
          println("Invoking: " + method.getName)
          try {
            method.invoke(null)
          } catch {
            case e: InvocationTargetException =>
              System.err.println(method.getName + " threw " + e.getTargetException.toString)
          }
        }
      })

    }
  }
}
